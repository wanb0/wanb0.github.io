<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaWeb入门</title>
      <link href="/2022/11/10/JavaWeb%E5%85%A5%E9%97%A8/"/>
      <url>/2022/11/10/JavaWeb%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一-WebServlet"><a href="#一-WebServlet" class="headerlink" title="一. WebServlet"></a>一. WebServlet</h1><h2 id="1-在idea中使用新建JavaWeb项目"><a href="#1-在idea中使用新建JavaWeb项目" class="headerlink" title="1. 在idea中使用新建JavaWeb项目"></a>1. 在idea中使用新建JavaWeb项目</h2><ul><li><p>先打开一个项目，或者新建一个项目，在项目中新建一个Module</p><p><img src="/../image/javaweb/javaweb1.png"></p><p><img src="/../image/javaweb/javaweb2.png"></p></li><li><p>新建一个测试页面，并把它部署到Tomcat中</p><ul><li><p>打开文件构建页面</p><p><img src="/../image/Javaweb/javaweb3.png"></p></li><li><p>给新模块新建一个artifacts</p><p><img src="/../image/Javaweb/javaweb4.png"></p></li><li><p>打开run的设置</p><p><img src="/../image/Javaweb/javaweb5.png"></p></li><li><p>添加Tomcat的本地服务</p><p><img src="/../image/Javaweb/javaweb6.png"></p></li><li><p>在deployment添加新增的artifacts</p><p><img src="/../image/Javaweb/javaweb7.png"></p></li><li><p>在server中设置启动项</p><p><img src="/../image/Javaweb/javaweb8.png"></p></li><li><p>在项目的web下新增一个web页面测试</p><p><img src="/../image/Javaweb/javaweb9.png"></p></li><li><p>点击debug或者运行尝试是否启动成功</p></li></ul><p>  <img src="/../image/Javaweb/javaweb10.png"></p><ul><li><p>显示刚才的web测试页面，即为部署成功</p><p><img src="/../image/Javaweb/javaweb11.png"></p></li></ul></li></ul><h2 id="2-在webapp目录下新建一个html文件"><a href="#2-在webapp目录下新建一个html文件" class="headerlink" title="2.在webapp目录下新建一个html文件"></a>2.在webapp目录下新建一个html文件</h2><p><img src="/../image/javaweb/javaweb12.png"></p><pre><code class="java">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;add&quot; method=&quot;post&quot;&gt;    名称：&lt;input type=&quot;text&quot; name=&quot;fname&quot; value=&quot;&quot;/&gt;&lt;br/&gt;    价格：&lt;input type=&quot;text&quot; name=&quot;price&quot; value=&quot;&quot;/&gt;&lt;br/&gt;    库存：&lt;input type=&quot;text&quot; name=&quot;fcount&quot; value=&quot;&quot;/&gt;&lt;br/&gt;    备注：&lt;input type=&quot;text&quot; name=&quot;remark&quot; value=&quot;&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;添加&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="3-新建一个Servlet类，用来获取表单数据"><a href="#3-新建一个Servlet类，用来获取表单数据" class="headerlink" title="3. 新建一个Servlet类，用来获取表单数据"></a>3. 新建一个Servlet类，用来获取表单数据</h2><p><img src="/../image/javaweb/javaweb13.png"></p><pre><code class="java">import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class AddServlets extends HttpServlet &#123;    @Override    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String fname = req.getParameter(&quot;fname&quot;);        String priceStr = req.getParameter(&quot;price&quot;);        Integer price = Integer.parseInt(priceStr);        String fcount = req.getParameter(&quot;fcount&quot;);        Integer count = Integer.parseInt(fcount);        String remark = req.getParameter(&quot;remark&quot;);        System.out.println(fname + price + count + remark);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隧道云超级管理员使用手册</title>
      <link href="/2022/11/10/%E7%AE%A1%E7%90%86%E5%91%98%E6%89%8B%E5%86%8C/"/>
      <url>/2022/11/10/%E7%AE%A1%E7%90%86%E5%91%98%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="隧道云管理员使用手册"><a href="#隧道云管理员使用手册" class="headerlink" title="隧道云管理员使用手册"></a>隧道云管理员使用手册</h1><h2 id="一-项目的结构层级"><a href="#一-项目的结构层级" class="headerlink" title="一. 项目的结构层级"></a>一. 项目的结构层级</h2><p><img src="/../image/shouce/cengji.png"></p><h2 id="二-系统结构功能"><a href="#二-系统结构功能" class="headerlink" title="二. 系统结构功能"></a>二. 系统结构功能</h2><p><img src="/../image/shouce/admin.png"></p><h2 id="三-系统功能演示"><a href="#三-系统功能演示" class="headerlink" title="三. 系统功能演示"></a>三. 系统功能演示</h2><h3 id="1-首页"><a href="#1-首页" class="headerlink" title="1. 首页"></a>1. 首页</h3><ul><li><p>登录之后首先进入到我们的首页，首页主要做<strong>数据概况</strong>的展示，不可做操作</p><p><img src="/../image/shouce/shouye.png"></p></li></ul><h3 id="2-项目概况"><a href="#2-项目概况" class="headerlink" title="2. 项目概况"></a>2. 项目概况</h3><ul><li><p>在<strong>项目概况——项目列表</strong>中浏览所有的项目</p><p><img src="/../image/shouce/xiangmuliebiao.png"></p></li><li><p>在<strong>项目概况——项目信息</strong>中修改项目的所有信息</p><p><img src="/../image/shouce/xiangmuxinxi.png"></p></li></ul><h3 id="3-配置信息"><a href="#3-配置信息" class="headerlink" title="3.配置信息"></a>3.配置信息</h3><ul><li>在<strong>配置信息——设备信息</strong>中，查看和修改各个设备的信息</li></ul><p><img src="/../image/shouce/shebeixinxi.png"></p><ul><li><p>在<strong>配置信息——通道信息</strong>中，查看和修改所有通道信</p><p><img src="/../image/shouce/tongdaoxinxi.png"></p></li></ul><h3 id="4-记录信息"><a href="#4-记录信息" class="headerlink" title="4.记录信息"></a>4.记录信息</h3><ul><li><p>在<strong>记录信息——实时记录</strong>中，选择要查看的设备号以及通道号，可以监测近一小时的通道传感器数据</p><p><img src="/../image/shouce/shishijilu.png"></p></li><li><p>在<strong>记录信息——历史记录</strong>中，选择好要查看的设备通道传感器，以及想要查询的时间段，就可以展示传感器记录的历史信息</p><p><img src="/../image/shouce/lishijilu.png"></p></li></ul><h3 id="5-预警管理"><a href="#5-预警管理" class="headerlink" title="5.预警管理"></a>5.预警管理</h3><ul><li><p>在<strong>预警信息</strong>中通过自己的编辑可以新建或者修改删除预警信息</p><p><img src="/../image/shouce/yujingxinxi.png"></p></li></ul><h3 id="6-图像处理"><a href="#6-图像处理" class="headerlink" title="6.图像处理"></a>6.图像处理</h3><ul><li><p>在<strong>图像处理——病害识别</strong>中，上传隧道岩层图片，就可以通过算法获取到识别结果。</p><p><img src="/../image/shouce/binghaishibie.png"></p></li></ul><h3 id="7-系统管理"><a href="#7-系统管理" class="headerlink" title="7. 系统管理"></a>7. 系统管理</h3><h4 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a>1. 用户管理</h4><ul><li><p>在管理员的用户管理页面可以管理本系统的所有用户</p><p><img src="/../image/shouce/yonghuguanli.png"></p></li><li><p>新增用户,填写用户信息之后，选择里面的角色，角色决定了用户的访问权限的问题，在角色管理中心可以自定义角色的权限</p><p><img src="/../image/shouce/adduser.png"></p></li></ul><h4 id="2-角色管理"><a href="#2-角色管理" class="headerlink" title="2.角色管理"></a>2.角色管理</h4><ul><li><p>这里的角色管理也就是方便用户权限的给予，不同的角色给予不同的权限，再为用户分配所属的角色</p><p><img src="/../image/shouce/jueseguanli.png"></p></li><li><p>用户可以根据角色的须要定制角色的系统菜单以及访问权限.</p><p><img src="/../image/shouce/addjuese.png"></p></li></ul><h4 id="3-菜单管理"><a href="#3-菜单管理" class="headerlink" title="3.菜单管理"></a>3.菜单管理</h4><ul><li><p>管理员用户可以根据业务需求选择编辑左侧的菜单功能</p><p><img src="/../image/shouce/caidanguanli.png"></p></li></ul><h4 id="4-部门管理"><a href="#4-部门管理" class="headerlink" title="4.部门管理"></a>4.部门管理</h4><ul><li><p>管理员可以根据业务需求对项目的部门进行修改和编辑</p><p><img src="/../image/shouce/bumenguanli.png"></p></li></ul><h4 id="5-字典管理"><a href="#5-字典管理" class="headerlink" title="5.字典管理"></a>5.字典管理</h4><ul><li>把页面中常用的、固定的变量(web开发中经常用到的下拉菜单option,单选框，复选框都可以使用这种方式)，可以把它设计为字典类型。然后项目启动的时候，可以把字典从数据库里面查出来，并且做缓存处理。好处是脱离页面硬编码，方便后期维护增删改， 减少了数据库的访问，加快页面响应速度…….</li></ul><p><img src="/../image/shouce/zidianguanli.png"></p><h4 id="6-参数设置"><a href="#6-参数设置" class="headerlink" title="6.参数设置"></a>6.参数设置</h4><ul><li><p>管理员可以根据业务需求对项目进行一些个性化设置，主题颜色、账户初试密码、侧边栏和验证码是否开启等都可在此设置</p><p><img src="/../image/shouce/canshushezhi.png"></p></li></ul><h4 id="7-通知公告"><a href="#7-通知公告" class="headerlink" title="7.通知公告"></a>7.通知公告</h4><ul><li><p>管理员可以发布一些公告信息</p><p><img src="/../image/shouce/tonggao.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web，suidao </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/11/06/JDBC%E7%9A%84%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2022/11/06/JDBC%E7%9A%84%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一-JDBC是什么"><a href="#一-JDBC是什么" class="headerlink" title="一. JDBC是什么"></a>一. JDBC是什么</h1><p>​<strong>JDBC</strong>(Java DataBase Connectivity) 称为Java数据库连接，它是一种用于数据库访问的应用程序API，由一组用Java语言编写的类和接口组成，有了JDBC就可以用统一的语法对多种关系数据库进行访问，而不用担心其数据库操作语言的差异。 有了JDBC，就不必为访问Mysql数据库专门写一个程序，为访问Oracle又专门写一个程序等等。</p><p><img src="/../image/jdbc/jdbc.png"></p><p>​ <strong>JDBC的结构可划分为两层：</strong>一个是面向底层的<strong>JDBC　Driver　Interface</strong>(驱动程序管理器接口)（各数据库厂商负责实现接口），另一个是面向程序员的<strong>JDBC　API</strong>。</p><p>​使用JDBC编程，可让开发人员从复杂的驱动器调用命令和函数中解脱出来，可以致力于应用程序中的关键地方。JDBC支持不同的关系数据库，这使得程序的可移植性大大加强。JDBC　API是面向对象的，可以让用户把常用的方法封装为—个类，以备后用。但是它也有缺点，一是使用JDBC，访问数据记录的速度会受到一定程度的影响。二是JDBC结构中包含不同厂家的产品，这就给更改数据源带来了很大的麻烦。</p><h1 id="二-JDBC的驱动类型"><a href="#二-JDBC的驱动类型" class="headerlink" title="二.JDBC的驱动类型"></a>二.JDBC的驱动类型</h1><p>​JDBC的驱动程序的存在，在JAVA程序和数据库之间建立了一条通信的渠道，根据访问数据库的技术不同， JDBC 驱动程序相应地分为四种类型。不同类型的驱动程序有着不一样的特性和使用方法。</p><ul><li><p><strong>JDBC-ODBC桥驱动程序(JDBC-ODBC Bridge Driver)</strong></p><p>此类驱动程序由JDBC-ODBC桥和一个ODBC驱动程序组成。其工作原理是，通过一段本地C代码将JDBC调用转化成ODBC调用。这一类型必须在本地计算机上先安装好ODBC驱动程序，然后通过JDBC-ODBCBridge的转换，将Java程序中使用的JDBCAPI访问指令转化成ODBCAPI指令，进而通过ODBC驱动程序调用本地数据库驱动代码完成对数据库的访问。</p></li><li><p><strong>部分Java的本地JDBCAPI驱动程序</strong></p><p>JDBC API驱动程序(Anative API partly Java technology-enabled Driver)此类驱动程序也必须在本地计算机上先安装好特定的驱动程序(类似ODBC)，然后通过PartialJavaJDBCDriver的转换，把Java程序中使用的JDBC API转换成NativeAPI，进而存取数据库。</p></li><li><p><strong>纯Java的数据库中间件驱动程序</strong></p><p>纯Java的数据库中间件驱动程序(Pure Java Driver for Database Middleware)使用这类驱动程序时，不需要在本地计算机上安装任何附加软件，但是必须在安装数据库管理系统的服务器端加装中间件(Middleware)，这个中间件负责所有存取数据库时必要的转换。其工作原理是：驱动程序将JDBC访问转换成与数据库无关的标准网络协议(通常是HTTP或HTTPS)送出，然后再由中间件服务器将其转换成数据库专用的访问指令，完成对数据库的操作。中间件服务器能支持对多种数据库的访问。</p></li><li><p><strong>纯Java的JDBC驱动程序</strong></p><p>纯Java的JDBC驱动程序(Direct-to-DatabasePureJavaDriver)这类驱动程序是直接面向数据库的纯Java驱动程序，即所谓的”瘦”驱动程序。使用这类驱动程序时无需安装任何附加的软件(无论是本地计算机或是数据库服务器端)，所有存取数据库的操作都直接由JDBC驱动程序来完成，此类驱动程序能将JDBC调用转换成DBMS专用的网络协议，能够自动识别网络协议下的特殊数据库并能直接创建数据连接</p></li></ul><h1 id="三-使用步骤"><a href="#三-使用步骤" class="headerlink" title="三. 使用步骤"></a>三. 使用步骤</h1><h2 id="1-载入JDBC驱动"><a href="#1-载入JDBC驱动" class="headerlink" title="1. 载入JDBC驱动"></a>1. 载入JDBC驱动</h2><ul><li><p><strong>MySQL的驱动下载和连接方式</strong></p><p>Maven下载方式</p><p>在中央仓库服务maven依赖包的配置</p><p>中央仓库的地址：<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">https://mvnrepository.com/artifact/mysql/mysql-connector-java</a></p><p><img src="/../image/jdbc/jdbc1.png"></p></li></ul><h2 id="2-注册驱动"><a href="#2-注册驱动" class="headerlink" title="2. 注册驱动"></a>2. 注册驱动</h2><pre><code class="java">Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //MySQL5以后的版本可以省略该步骤，也不会报错</code></pre><h2 id="3-获取连接"><a href="#3-获取连接" class="headerlink" title="3.获取连接"></a>3.获取连接</h2><pre><code class="java"> Connection conn=DriverManager.getConnection(&quot;url&quot;, &quot;username&quot;, &quot;password&quot;); String url=&quot;jdbc:mysql://localhost:3306/test&quot;;   //数据库连接地址和数据库的名称 String username = &quot;root&quot;;                        //数据库登录的用户名 String password = &quot;******&quot;;                      //数据库用户的密码</code></pre><h2 id="4-定义sql语句"><a href="#4-定义sql语句" class="headerlink" title="4.定义sql语句"></a>4.定义sql语句</h2><pre><code class="java"> String sql=&quot;update user set user_name=&#39;che&#39; where id=2&quot;; //修改user表中的id=2的user_name=&quot;che&quot;</code></pre><h2 id="5-获取执行sql的对象Statement"><a href="#5-获取执行sql的对象Statement" class="headerlink" title="5.获取执行sql的对象Statement"></a>5.获取执行sql的对象Statement</h2><pre><code class="java">Statement stmt=conn.createStatement(); </code></pre><h2 id="6-执行sql"><a href="#6-执行sql" class="headerlink" title="6.执行sql"></a>6.执行sql</h2><pre><code class="java">int count=stmt.executeUpdate(sql); //返回值是一个整数（int），指示受影响的行数（即更新计数）</code></pre><h2 id="7-打印结果"><a href="#7-打印结果" class="headerlink" title="7.打印结果"></a>7.打印结果</h2><pre><code class="java">System.out.println(count);</code></pre><h2 id="8-释放资源"><a href="#8-释放资源" class="headerlink" title="8.释放资源"></a>8.释放资源</h2><pre><code class="java">stmt.close();conn.close();</code></pre><h1 id="四-JDBCAPI"><a href="#四-JDBCAPI" class="headerlink" title="四.JDBCAPI"></a>四.JDBCAPI</h1><h2 id="1-DriverManager"><a href="#1-DriverManager" class="headerlink" title="1.DriverManager"></a>1.DriverManager</h2><ul><li><p>注册驱动</p><p>sql的jar包中可以自动注册驱动</p><p><img src="/../image/jdbc/jdbc2.png"></p><p><img src="/../image/jdbc/jdbc3.png"></p></li><li><p>获取数据库连接</p></li></ul><pre><code class="java"> 如果连接本机的3306端口，url的格式可以简化为 String url=&quot;jdbc:mysql:///test&quot;; url的格式为jdbc:mysql://地址:端口/数据库名称?参数键值对</code></pre><h2 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2. Connection"></a>2. Connection</h2><ul><li><p>获取执行sql的对象</p><ul><li><p>普通执行SQL对象</p><pre><code class="java">Statement createStatement()</code></pre></li><li><p>预编译SQL执行的SQL对象：防止SQL注入</p><pre><code class="java">PreparedStatement PreparedStatement(sql)</code></pre></li><li><p>执行存储对象的过程</p><pre><code class="java">CallableStatement PrepareCall(sql)</code></pre></li></ul></li><li><p>管理事务</p><p>事务是一组数据库操作语句（DML），一组要么全部成功，要么全部失败。</p><p>事务是多个操作构成的实现一个事情的整体。</p><ul><li><p><strong>MySQL事务管理</strong></p><pre><code>开启事务:BEGIN;提交事务:COMMIT;回滚事务:ROLLBACk;MySQL默认自动提交事务</code></pre></li><li><p><strong>JDBC事务管理：</strong>Connection接口中定义了3个对应的方法</p><pre><code>开启事务：setAutoCommit(Boolean autoCommit)  ture为自动提交 false为手动提交，即为开启事务提交事务：commit()回滚事务：rollback()</code></pre></li></ul></li></ul><h2 id="3-Statement"><a href="#3-Statement" class="headerlink" title="3.Statement"></a>3.Statement</h2><ul><li>执行sql语句</li></ul><pre><code class="java">int executeUpdata(sql):执行DML\DDL语句  DML对表操作  DDL对于库的操作返回值：（1）DDL语句影响的行数（2）DDL语句执行成功也可能返回0</code></pre><pre><code class="java">Resulet executeQuery(sql):执行DQL语句返回值：ResultSET结果集对象</code></pre><h2 id="4-ResultSet"><a href="#4-ResultSet" class="headerlink" title="4.ResultSet"></a>4.ResultSet</h2><ul><li>ResultSet(结果集对象)作用：</li></ul><p>1.封装了DQL查询语句的结果</p><pre><code class="java">ResultSet stmt executeQuery(sql):执行DQL语句返回ResultSet对象</code></pre><ul><li>获取查询结果</li></ul><pre><code class="java">boolean next():(1)将光标从当前位置向前移动一行（2）判断当前行是否为有效行返回值：    true：有效行，当前行有数据    false：无效行，当前行无数据</code></pre><pre><code class="java">xxx getXxx(参数)：获取数据xxx：数据类型 如: int getInt String  getString    参数：        int：列的编号，从1开始        String：列的名称</code></pre><ul><li><p>使用步骤：</p><p>1.游标向下移动一行，并判断该行是否有数据</p><p>2.获取数据：getXxx(参数)</p><pre><code class="java">//循环判断游标是否是最后一行末尾while(rs.next())&#123;    //获取数据    rs.getXxx(参数);&#125;</code></pre></li><li><p>实例代码</p><pre><code class="java">    @Test    public void testResultSet2()throws Exception &#123;        String url=&quot;jdbc:mysql://localhost:3306/test&quot;;        String username=&quot;root&quot;;        String password=&quot;aA123456!&quot;;        Connection conn = DriverManager.getConnection(url, username, password);        //定义SQL语句        String sql = &quot;select * from account&quot;;        // 获取执行SQL的对象A        Statement stmt = conn.createStatement();        // 执行SQL        ResultSet rs = stmt.executeQuery(sql);        // 处理结果        // 循环判断游标是否是最后一行末尾        List&lt;Account&gt; list = new ArrayList&lt;Account&gt;();        while (rs.next()) &#123;            Account account=new Account();            int id = rs.getInt(1);            String name = rs.getString(2);            double money = rs.getDouble(3);            account.setId(id);            account.setName(name);            account.setMoney(money);            list.add(account);        &#125;        // 释放资源        rs.close();        stmt.close();        conn.close();        System.out.println(list);    &#125;</code></pre></li></ul><h2 id="5-PreparedStatement"><a href="#5-PreparedStatement" class="headerlink" title="5.PreparedStatement"></a>5.PreparedStatement</h2><ul><li><ul><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>执行时就不用这些步骤了，速度更快</li><li>如果多个sql模板一样，则只需进行一次检查、编译</li></ul></li><li><p>预编译SQL语句，预防SQL注入问题</p></li><li><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></li><li><p>预编译SQL并执行SQL语句</p><p>获取PreparedStatement对象</p><pre><code class="java">//SQL语句的参数值，使用？代替String sql=&quot;select * from user where username = ? and password = ?&quot;;//通过Connectio对象获取，并传入对应的SQL语句PreparedStatement pstmt=conn.preparedStatement(sql);</code></pre><p>设置参数值</p><pre><code class="java"> //给占位符赋值pstmt.setString(1,name);pstmt.setString(2,pwd);</code></pre></li></ul><p>​执行<strong>SQLResultSet rs &#x3D; pstmt.executeQuery();</strong></p><ul><li>代码</li></ul><pre><code class="java"> public void testPreparedStatement() throws Exception &#123;         //useSSL=false&amp;useServerPrepStmts=true 开启预编译的指令        String url = &quot;jdbc:mysql://localhost:3306/db1?useSSL=false&amp;useServerPrepStmts=true&quot;;        String username = &quot;root&quot;;        String password = &quot;aA123456!&quot;;        Connection conn = DriverManager.getConnection(url, username, password);        String name=&quot;che&quot;;        String pwd=&quot;123&quot;;        String sql = &quot;select * from tb_user where username= ? and password= ?&quot;;        //创建PreparedStatement对象        PreparedStatement pstmt = conn.prepareStatement(sql);        //给占位符赋值        pstmt.setString(1,name);        pstmt.setString(2,pwd);        //执行SQL        ResultSet rs = pstmt.executeQuery();        //判断是否登录成功        if (rs.next()) &#123;            System.out.println(&quot;登录成功&quot;);        &#125; else &#123;            System.out.println(&quot;登录失败&quot;);        &#125;        rs.close();        pstmt.close();        conn.close();</code></pre><h1 id="五-数据库连接池"><a href="#五-数据库连接池" class="headerlink" title="五.数据库连接池"></a>五.数据库连接池</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul><li><p><strong>数据库连接池是个容器</strong>，负责分配、管理数据库连接（Connection）</p></li><li><p>它允许应用程序重复使用一个现有的连接池，而不是再重新建立一个</p></li><li><p>释放空间时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li><p>好处</p><ul><li>资源重用</li><li>提升系统相应速度</li><li>避免数据库连接遗漏</li></ul><p><img src="/../image/jdbc/jdbc4.png"></p></li></ul><h2 id="2-Driud-德鲁伊-数据连接池使用步骤"><a href="#2-Driud-德鲁伊-数据连接池使用步骤" class="headerlink" title="2.Driud(德鲁伊)数据连接池使用步骤"></a>2.Driud(德鲁伊)数据连接池使用步骤</h2><h3 id="1-导入jar包"><a href="#1-导入jar包" class="headerlink" title="1.导入jar包"></a>1.导入jar包</h3><ul><li><p>通过Maven在pom文件中添加依赖</p><p><img src="/../image/jdbc/jdbc5.png"></p></li></ul><h3 id="2-定义配置文件"><a href="#2-定义配置文件" class="headerlink" title="2. 定义配置文件"></a>2. 定义配置文件</h3><ul><li><p>在resources目录下新建druid.properties文件进行配置，配置信息可以去查看根据自己需求配置</p><pre><code class="http">https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8</code></pre><pre><code class="java">//druid.properties配置文件driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/testusername=rootpassword=aA123456!initialSize=10minIdle=1maxActive=10maxWait=10000timeBetweenEvictionRunsMillis=6000minEvictableIdleTimeMillis=300000testWhileIdle=truetestOnBorrow=truetestOnReturn=truepoolPreparedStatements=truemaxPoolPreparedStatementPerConnectionSize=20validationQuery=select 1filters=stat</code></pre></li></ul><h3 id="3-加载配置文件"><a href="#3-加载配置文件" class="headerlink" title="3. 加载配置文件"></a>3. 加载配置文件</h3><pre><code class="java">Properties prop = new Properties();prop.load(new FileInputStream(&quot;src/main/resources/druid.properties&quot;));</code></pre><h3 id="4-获取数据库池连接对象"><a href="#4-获取数据库池连接对象" class="headerlink" title="4. 获取数据库池连接对象"></a>4. 获取数据库池连接对象</h3><pre><code class="java">DruidDataSource dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(prop);</code></pre><h3 id="5-获取连接"><a href="#5-获取连接" class="headerlink" title="5. 获取连接"></a>5. 获取连接</h3><pre><code class="java">Connection connection = dataSource.getConnection();</code></pre><h1 id="六-JDBC基本操作练习"><a href="#六-JDBC基本操作练习" class="headerlink" title="六. JDBC基本操作练习"></a>六. JDBC基本操作练习</h1><h2 id="1-数据库代码"><a href="#1-数据库代码" class="headerlink" title="1. 数据库代码"></a>1. 数据库代码</h2><pre><code class="sql">DROP TABLE IF EXISTS tb_brand;CREATE TABLE tb_brand(    id int NOT NULL AUTO_INCREMENT,    brand_name VARCHAR(20),    company_name VARCHAR(20),    ordered int,    description VARCHAR(100),    status int,    PRIMARY KEY (`id`));INSERT into tb_brand (brand_name,company_name,ordered,description,status)VALUES(&#39;三只松鼠&#39;,&#39;三只松鼠股份有限公司&#39;,5,&#39;好吃不上火&#39;,0),            (&#39;华为&#39;,&#39;华为技术有限公司&#39;,100,&#39;华为5G&#39;,1),            (&#39;小米&#39;,&#39;小米技术有限公司&#39;,50,&#39;为发烧而生&#39;,1);SELECT * FROM tb_brand;</code></pre><h2 id="2-实体类代码"><a href="#2-实体类代码" class="headerlink" title="2. 实体类代码"></a>2. 实体类代码</h2><pre><code class="java">/** * 品牌实体类 * alt+鼠标左键 选中多行编辑 * 建议在实体类中基本数据类型使用包装类，不让默认值产生业务影响 */public class Brand &#123;    //品牌id主键     private  Integer id;    //品牌名称     private  String brandName;    //品牌描述     private  String companyName;    //排序字段     private  Integer ordered;     //描述信息     private  String description;     //状态 0：禁用 1：启用     private  Integer status;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getBrandName() &#123;        return brandName;    &#125;    public void setBrandName(String brandName) &#123;        this.brandName = brandName;    &#125;    public String getCompanyName() &#123;        return companyName;    &#125;    public void setCompanyName(String companyName) &#123;        this.companyName = companyName;    &#125;    public Integer getOrdered() &#123;        return ordered;    &#125;    public void setOrdered(Integer ordered) &#123;        this.ordered = ordered;    &#125;    public String getDescription() &#123;        return description;    &#125;    public void setDescription(String description) &#123;        this.description = description;    &#125;    public Integer getStatus() &#123;        return status;    &#125;    public void setStatus(Integer status) &#123;        this.status = status;    &#125;    @Override    public String toString() &#123;        return &quot;Brand&#123;&quot; +                &quot;id=&quot; + id +                &quot;, brandName=&#39;&quot; + brandName + &#39;\&#39;&#39; +                &quot;, companyName=&#39;&quot; + companyName + &#39;\&#39;&#39; +                &quot;, ordered=&quot; + ordered +                &quot;, description=&#39;&quot; + description + &#39;\&#39;&#39; +                &quot;, status=&quot; + status +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h2 id="3-查询测试类代码"><a href="#3-查询测试类代码" class="headerlink" title="3. 查询测试类代码"></a>3. 查询测试类代码</h2><pre><code class="java">import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import com.pojo.Brand;import org.testng.annotations.Test;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import java.util.Properties;/** * 品牌的增删改查测试类 */public class BrandTest &#123;    /**     * 查询所有品牌     * 1.Sql：select * from tb_brand     * 2.参数：无     * 3.返回值：List&lt;Brand&gt;     */    @Test    public void testSelectAll() throws Exception &#123;        //1.创建连接        //加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(&quot;src/main/resources/druid.properties&quot;));        //获取连接池对象        DruidDataSource dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(prop);        //获取连接        Connection conn= dataSource.getConnection();        //2.创建语句        String sql = &quot;select * from tb_brand&quot;;        //获取pstmt对象        PreparedStatement pstmt = conn.prepareStatement(sql);        //设置参数        //执行SQL        ResultSet rs = pstmt.executeQuery(sql);        //处理结果,封装Brand对象,添加到List集合        List&lt;Brand&gt; brands =new ArrayList&lt;&gt;();        while (rs.next())&#123;            //获取数据            int id = rs.getInt(&quot;id&quot;);            String brand_name = rs.getString(&quot;brand_name&quot;);            String company_name = rs.getString(&quot;company_name&quot;);            int ordered = rs.getInt(&quot;ordered&quot;);            String description = rs.getString(&quot;description&quot;);            int status = rs.getInt(&quot;status&quot;);            //封装Brand对象            Brand brand = new Brand();            brand.setId(id);            brand.setBrandName(brand_name);            brand.setCompanyName(company_name);            brand.setOrdered(ordered);            brand.setDescription(description);            brand.setStatus(status);            //添加到List集合            brands.add(brand);        &#125;        System.out.println(brands);        //释放资源        rs.close();        pstmt.close();        conn.close();    &#125;&#125;</code></pre><h2 id="4-增加测试类"><a href="#4-增加测试类" class="headerlink" title="4. 增加测试类"></a>4. 增加测试类</h2><pre><code class="java"> /**     * 增加品牌     * 1.Sql：insert into tb_brand(brand_name,company_name,ordered,description,status) values(?,?,?,?,?)     * 2.参数：须要，除了id之外的所有字段     * 3.结果：Boolean     */    @Test    public void testAdd() throws Exception &#123;        //接收页面提交的参数        String brandName1 = &quot;香飘飘&quot;;        String companyName1 = &quot;香飘飘公司&quot;;        int ordered1 = 1;        String description1 = &quot;香飘飘是一家很好的公司&quot;;        int status1 = 1;        //创建连接        //加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(&quot;src/main/resources/druid.properties&quot;));        //获取连接池对象        DruidDataSource dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(prop);        //获取连接        Connection conn= dataSource.getConnection();        //创建语句        String sql = &quot;insert into tb_brand(brand_name,company_name,ordered,description,status) values(?,?,?,?,?)&quot;;        //获取pstmt对象        PreparedStatement pstmt = conn.prepareStatement(sql);        //设置参数        pstmt.setString(1,brandName1);        pstmt.setString(2,companyName1);        pstmt.setInt(3,ordered1);        pstmt.setString(4,description1);        pstmt.setInt(5,status1);        //执行SQL        int count = pstmt.executeUpdate();        //处理结果        System.out.println(count);        //释放资源        pstmt.close();        conn.close();    &#125;</code></pre><h2 id="5-修改测试类（by-id）"><a href="#5-修改测试类（by-id）" class="headerlink" title="5. 修改测试类（by id）"></a>5. 修改测试类（by id）</h2><pre><code class="java"> /**     * 修改品牌     * 1.Sql：update tb_brand set brand_name=?,company_name=?,ordered=?,description=?,status=? where id=?     * 2.参数：须要，所有字段     * 3.结果：Boolean     */    @Test    public void testUpdate() throws Exception &#123;        //接收页面提交的参数        String brandName1 = &quot;香飘飘&quot;;        String companyName1 = &quot;香飘飘公司&quot;;        int ordered1 = 1000;        String description1 = &quot;香飘飘家很好的公司&quot;;        int status1 = 1;        int id1 = 3;        //创建连接        //加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(&quot;src/main/resources/druid.properties&quot;));        //获取连接池对象        DruidDataSource dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(prop);        //获取连接        Connection conn= dataSource.getConnection();        //创建语句        String sql = &quot;update tb_brand set brand_name=?,company_name=?,ordered=?,description=?,status=? where id=?&quot;;        //获取pstmt对象        PreparedStatement pstmt = conn.prepareStatement(sql);        //设置参数        pstmt.setString(1,brandName1);        pstmt.setString(2,companyName1);        pstmt.setInt(3,ordered1);        pstmt.setString(4,description1);        pstmt.setInt(5,status1);        pstmt.setInt(6,id1);        //执行SQL        int count = pstmt.executeUpdate();        //处理结果        System.out.println(count&gt;0?&quot;修改成功&quot;:&quot;修改失败&quot;);        //释放资源        pstmt.close();        conn.close();    &#125;</code></pre><h2 id="6-删除测试类代码（by-id）"><a href="#6-删除测试类代码（by-id）" class="headerlink" title="6. 删除测试类代码（by id）"></a>6. 删除测试类代码（by id）</h2><pre><code class="java">/**     * 删除     * 1.Sql：delete from tb_brand where id=?     * 2.参数：须要，id     * 3.结果：Boolean     */    @Test    public void testDeleteById() throws Exception &#123;        //接收页面提交的参数        String brandName1 = &quot;香飘飘&quot;;        String companyName1 = &quot;香飘飘公司&quot;;        int ordered1 = 1000;        String description1 = &quot;香飘飘家很好的公司&quot;;        int status1 = 1;        int id1 = 3;        //创建连接        //加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(&quot;src/main/resources/druid.properties&quot;));        //获取连接池对象        DruidDataSource dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(prop);        //获取连接        Connection conn= dataSource.getConnection();        //创建语句        String sql = &quot;delete from tb_brand where id=?&quot;;        //获取pstmt对象        PreparedStatement pstmt = conn.prepareStatement(sql);        //设置参数        pstmt.setInt(1,id1);        //执行SQL        int count = pstmt.executeUpdate();        //处理结果        System.out.println(count&gt;0?&quot;修改成功&quot;:&quot;修改失败&quot;);        //释放资源        pstmt.close();        conn.close();    &#125;</code></pre><h1 id="七-数据库事务"><a href="#七-数据库事务" class="headerlink" title="七. 数据库事务"></a>七. 数据库事务</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><h3 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务"></a>1. 什么是事务</h3><p>事务是一组数据库操作语句（DML），一组要么全部成功，要么全部失败。</p><p>数据库事务是一组逻辑操作单元，使数据从一中状态到另一种状态。</p><p>事务是多个操作构成的实现一个事情的整体。</p><h3 id="2-事务的ACID属性"><a href="#2-事务的ACID属性" class="headerlink" title="2. 事务的ACID属性"></a>2. 事务的ACID属性</h3><ul><li><h4 id="Atomic（原子性）："><a href="#Atomic（原子性）：" class="headerlink" title="Atomic（原子性）："></a>Atomic（原子性）：</h4><p>指整个数据库事务是不可分割的工作单位。只有使数据库中所有的操作执行成功，才算整个事务成功；</p><p>事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。</p></li><li><h4 id="Consistency（一致性）："><a href="#Consistency（一致性）：" class="headerlink" title="Consistency（一致性）："></a>Consistency（一致性）：</h4><p>指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后user表中AA和BB的存款总额为2000元。</p></li><li><h4 id="Isolation（隔离性）："><a href="#Isolation（隔离性）：" class="headerlink" title="Isolation（隔离性）："></a>Isolation（隔离性）：</h4><p>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间，不会互相干扰。</p></li><li><h4 id="Durability（持久性）："><a href="#Durability（持久性）：" class="headerlink" title="Durability（持久性）："></a>Durability（持久性）：</h4><p>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p></li></ul><h2 id="2-事务管理基本方法"><a href="#2-事务管理基本方法" class="headerlink" title="2.事务管理基本方法"></a>2.事务管理基本方法</h2><ul><li><p><strong>MySQL事务管理</strong></p><pre><code>开启事务:BEGIN;提交事务:COMMIT;回滚事务:ROLLBACk;MySQL默认自动提交事务</code></pre></li><li><p><strong>JDBC事务管理：</strong>Connection接口中定义了3个对应的方法</p><pre><code>开启事务：setAutoCommit(Boolean autoCommit)  ture为自动提交 false为手动提交，即为开启事务提交事务：commit()回滚事务：rollback() </code></pre></li><li><p>数据一旦提交不可回滚</p></li><li><p>哪些操作会导致数据的自动提交？</p><ul><li>DDL操作</li><li>DML默认也会自动提交，但可以通过Set autocommit &#x3D; false 方式取消DML的自动提交，对DDL的操作不生效</li></ul></li></ul><h2 id="3-转账案例演示"><a href="#3-转账案例演示" class="headerlink" title="3. 转账案例演示"></a>3. 转账案例演示</h2><h3 id="1-测试类"><a href="#1-测试类" class="headerlink" title="1. 测试类"></a>1. 测试类</h3><pre><code class="java">/**     * 考虑事务的测试类     * @throws SQLException     */    @Test    public void TestUpdate() throws SQLException &#123;        //1.注册驱动，获取连接        String url = &quot;jdbc:mysql://localhost:3306/db1?useSSL=false&amp;useServerPrepStmts=true&quot;;        String username = &quot;root&quot;;        String password = &quot;aA123456!&quot;;        Connection conn = DriverManager.getConnection(url, username, password);        try &#123;            //2.取消自动提交            conn.setAutoCommit(false);            String sql1 = &quot;update tb_user set password = password - 100 where id = 1&quot;;            TestShiWu(conn, sql1,&quot;AA&quot;);            System.out.println(10/0);//模拟异常            String sql2 = &quot;update tb_user set password = password + 100 where id = 2&quot;;            TestShiWu(conn, sql2,&quot;BB&quot;);            System.out.println(&quot;转账成功&quot;);            //3.提交事务            conn.commit();        &#125; catch (Exception e) &#123;            e.printStackTrace();            //回滚事务            conn.rollback();        &#125;finally &#123;            close(conn);        &#125;    &#125;</code></pre><h3 id="2-事务类"><a href="#2-事务类" class="headerlink" title="2. 事务类"></a>2. 事务类</h3><pre><code class="java"> @Test    public int TestShiWu(Connection conn, String sql, Object... args) throws SQLException &#123;        PreparedStatement pstmt = null;        try &#123;            //预编译sql语句            pstmt = conn.prepareStatement(sql);            //执行sql语句            return pstmt.executeUpdate();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(pstmt);        &#125;        return 0;    &#125;</code></pre><h2 id="4-数据库的隔离级别"><a href="#4-数据库的隔离级别" class="headerlink" title="4. 数据库的隔离级别"></a>4. 数据库的隔离级别</h2><h3 id="1-MySQL四种隔离级别定义"><a href="#1-MySQL四种隔离级别定义" class="headerlink" title="1. MySQL四种隔离级别定义"></a>1. MySQL四种隔离级别定义</h3><p><strong>MySQL 中事务的隔离级别一共分为四种，分别如下，默认为可重复读（REPEATABLE READ）：</strong></p><ul><li><strong>读未提交（READ UNCOMMITTED）</strong></li></ul><p>​在这个隔离级别，所有事务都可以看到未提交事务的执行结果。在这种隔离级别上，可能会产生很多问题。所以这种隔离级别很少用于实际应用，而且它的性能也没有比其他性能好很多，而别的级别还有其他的优点。读取未提交数据，也被称为“脏读”。</p><ul><li><strong>读已提交（READ COMMITTED）</strong></li></ul><p>​读已提交这种隔离级别是大多数数据库系统默认的隔离级别（但mysql默认的隔离级别却不是这种），满足了隔离的最早简单定义：一个事务开始时，只能看见已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别也支持所谓的不可重复读。这意味着用户运行同一个语句两次，看到的结果是不同的。</p><ul><li><strong>可重复读 （REPEATABLE READ）</strong></li></ul><p>​mysql数据库默认的隔离级别。该级别解决了READ UNCOMMITTED导致的问题。它保证了同一事务的多个实例在并发读取事务时，会看到同样的数据行。不过这会导致另外一个问题“幻读”。InnoDB和Falcon存储引擎通过多版本并发控制解决了幻读问题。</p><ul><li><strong>可串行化 （SERIALIZABLE）</strong></li></ul><p>​该隔离级别是最高的隔离级别。它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之：SERIALIZABLE是在每个读的数据行加锁，在这个级别上可能导致大量的超时和锁竞争现象，实际应用中很少使用这个级别，但如果用户的应用为了数据的稳定性，需要强制减少并发，也可以选择这种隔离级别。</p><h3 id="2-隔离级别产生的问题"><a href="#2-隔离级别产生的问题" class="headerlink" title="2. 隔离级别产生的问题"></a>2. 隔离级别产生的问题</h3><ul><li><strong>脏读</strong></li></ul><p>​脏读是指一个事务读物了未提交事务执行过程中的数据。</p><p>​当一个事务的操作正在多次进行修改数据，而在事务还未提交的时候，另外一个并发事务来读取了数据，就会导致读取到的数据并非是最终持久化之后的数据，这个数据就是脏读的数据。</p><ul><li><strong>不可重复读</strong></li></ul><p>​不可重复读是指对于数据库中的某个数据，一个事务的执行过程中多次查询返回不同的查询结果，这就是事务在执行过程中，数据被其他事务提交修改了。</p><p>​不可重复读和脏读的区别在于：脏读是一个事务读取了另一未完成的事务执行过程中的数据，而不可重复读是一个事务执行过程中，另一事务提交并修改了当前事务正在读取的数据。</p><ul><li><strong>幻读</strong></li></ul><p>​幻读是事务非独立执行时发生的一种现象，例如事务1批量对一张表中某一列值为1的数据修改为2的数据的变更，但是在这时，事务T2对这张表插入了一条列值为1的数据，并完成提交。此时，如果事务T1查看刚刚完成操作的数据，发现还有一条列值为1的数据没有修改，而这条数据是t2刚刚提交插入的，这就是幻读。</p><p>​幻读和不可重复读都是读取了另一条已经提交的事务，所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td><strong>读未提交（READ UNCOMMITTED）</strong></td><td>√</td><td>√</td><td>√</td></tr><tr><td><strong>读已提交（READ COMMITTED）</strong></td><td>×</td><td>√</td><td>√</td></tr><tr><td><strong>可重复读 （REPEATABLE READ）</strong></td><td>×</td><td>×</td><td>√</td></tr><tr><td><strong>可串行化 （SERIALIZABLE）</strong></td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>读未提交会发生脏读，一般使用读已提交或者是可重复读。</li></ul><h3 id="3-查看修改隔离级别"><a href="#3-查看修改隔离级别" class="headerlink" title="3.查看修改隔离级别"></a>3.查看修改隔离级别</h3><ul><li><p>MySQL8.0查看隔离级别</p><pre><code class="bash">mysql&gt; select @@transaction_isolation;+-------------------------+| @@transaction_isolation |+-------------------------+| REPEATABLE-READ         |+-------------------------+</code></pre></li><li><p>局部修改隔离级别</p><pre><code class="java">-- 设置本次会话的事务隔离级别，只在本会话有效，不会影响到其它会话mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)-- 再次查看发现已改成了read committedmysql&gt; select @@transaction_isolation;+-------------------------+| @@transaction_isolation |+-------------------------+| READ-COMMITTED          |+-------------------------+-- 再登录其它窗口，再查看，发现还是repeatable readmysql&gt; select @@transaction_isolation;+-------------------------+| @@transaction_isolation |+-------------------------+| REPEATABLE-READ         |+-------------------------+</code></pre></li><li><p>全局修改隔离级别</p><p>设置全局的事务隔离级别，该设置不会影响当前已经连接的会话，设置完毕后，新打开的会话，将使用新设置的事务隔离级别</p><pre><code class="bash">-- 设置全局的事务隔离级别mysql&gt; set global transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)-- 不影响本次已连接会话的事务，所以查到的还是修改前的mysql&gt; select @@transaction_isolation;+-------------------------+| @@transaction_isolation |+-------------------------+| REPEATABLE-READ         |+-------------------------+-- 再打开一个新会话，则变成了修改后的read committedmysql&gt; select @@transaction_isolation;+-------------------------+| @@transaction_isolation |+-------------------------+| READ-COMMITTED          |+-------------------------+</code></pre></li><li><p>设置下一次事务操作的隔离级别，该设置会随着下一次事务的提交而失效</p><pre><code class="bash">-- 查看自动提交是否开启mysql&gt; show variables like &#39;autocommit&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | ON    |+---------------+-------+-- 关闭自动提交mysql&gt; set autocommit = 0;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &#39;autocommit&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | OFF   |+---------------+-------+-- 设置本次事务set transaction isolation level read uncommitted;-- 提交事务commit;</code></pre></li><li><h4 id="通过配置文件my-ini也可以修改事务"><a href="#通过配置文件my-ini也可以修改事务" class="headerlink" title="通过配置文件my.ini也可以修改事务"></a>通过配置文件my.ini也可以修改事务</h4></li></ul><pre><code class="java">[mysqld]transaction-isolation = REPEATABLE-READtransaction-read-only = OFF</code></pre><ul><li><p>在java代码中查看修改隔离级别</p><pre><code class="java">Connection conn = DriverManager.getConnection(url, username, password); //获取当前连接的隔离级别System.out.println(conn.getTransactionIsolation());//设置数据库的隔离级别conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);//取消自动提交数据conn.setAutoCommit(false); </code></pre></li></ul><h1 id="八-DAO及其实现类"><a href="#八-DAO及其实现类" class="headerlink" title="八.  DAO及其实现类"></a>八.  DAO及其实现类</h1><h2 id="1-底层DAO类，通用操作"><a href="#1-底层DAO类，通用操作" class="headerlink" title="1.底层DAO类，通用操作"></a>1.底层DAO类，通用操作</h2><pre><code class="java">package com.DAO;import org.testng.annotations.Test;import java.lang.reflect.Field;import java.sql.*;import static com.alibaba.druid.util.JdbcUtils.close;/** *针对数据表的通用的操作 */public abstract class BaseDAO &#123;    //通用的增删改操作    @Test    public int UpDate(Connection conn, String sql, Object... args) throws SQLException &#123;        PreparedStatement pstmt = null;        try &#123;            //预编译sql语句            pstmt = conn.prepareStatement(sql);            //填充占位符            for (int i = 0; i &lt; args.length; i++) &#123;                pstmt.setObject(i + 1, args[i]);            &#125;            //执行sql语句            return pstmt.executeUpdate();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(pstmt);        &#125;        return 0;    &#125;    //通用的查询操作，返回表中的一条记录    @Test    public &lt;T&gt; T getInstance(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) throws SQLException &#123;        PreparedStatement pstmt = null;        ResultSet rs = null;        try &#123;            //预编译sql语句            pstmt = conn.prepareStatement(sql);            //填充占位符            for (int i = 0; i &lt; args.length; i++) &#123;                pstmt.setObject(i + 1, args[i]);            &#125;            //执行sql语句            rs = pstmt.executeQuery();            //获取结果集的元数据            ResultSetMetaData rsmd = rs.getMetaData();            //获取列数            int columnCount = rsmd.getColumnCount();            if (rs.next()) &#123;                T t = clazz.newInstance();                //处理结果集一行数据中的每一列                for (int i = 0; i &lt; columnCount; i++) &#123;                    //获取列值                    Object columnValue = rs.getObject(i + 1);                    //获取每个列的列名                    String columnLabel = rsmd.getColumnLabel(i + 1);                    //给t对象指定的columnName属性，赋值为columnValue，通过反射                    Field field = clazz.getDeclaredField(columnLabel);                    field.setAccessible(true);                    field.set(t, columnValue);                &#125;                return t;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(rs);            close(pstmt);        &#125;        return null;    &#125;    //通用的查询操作，返回表中的多条记录构成的集合    @Test    public &lt;T&gt; T getForList(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args) throws SQLException &#123;        PreparedStatement pstmt = null;        ResultSet rs = null;        try &#123;            //预编译sql语句            pstmt = conn.prepareStatement(sql);            //填充占位符            for (int i = 0; i &lt; args.length; i++) &#123;                pstmt.setObject(i + 1, args[i]);            &#125;            //执行sql语句            rs = pstmt.executeQuery();            //获取结果集的元数据            ResultSetMetaData rsmd = rs.getMetaData();            //获取列数            int columnCount = rsmd.getColumnCount();            if (rs.next()) &#123;                T t = clazz.newInstance();                //处理结果集一行数据中的每一列                for (int i = 0; i &lt; columnCount; i++) &#123;                    //获取列值                    Object columnValue = rs.getObject(i + 1);                    //获取每个列的列名                    String columnLabel = rsmd.getColumnLabel(i + 1);                    //给t对象指定的columnName属性，赋值为columnValue，通过反射                    Field field = clazz.getDeclaredField(columnLabel);                    field.setAccessible(true);                    field.set(t, columnValue);                &#125;                return t;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(rs);            close(pstmt);        &#125;        return null;    &#125;    //用于查询特殊值的通用的方法    @Test    public &lt;E&gt; E getValue(Connection conn, String sql, Object... args) &#123;        PreparedStatement pstmt = null;        ResultSet rs = null;        try &#123;            //预编译sql语句            pstmt = conn.prepareStatement(sql);            //填充占位符            for (int i = 0; i &lt; args.length; i++) &#123;                pstmt.setObject(i + 1, args[i]);            &#125;            //执行sql语句            rs = pstmt.executeQuery();            if (rs.next()) &#123;                return (E) rs.getObject(1);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(rs);            close(pstmt);        &#125;        return null;    &#125;&#125;</code></pre><h2 id="2-对操作的表写一个接口"><a href="#2-对操作的表写一个接口" class="headerlink" title="2. 对操作的表写一个接口"></a>2. 对操作的表写一个接口</h2><pre><code class="java">package com.DAO;import com.bean.Customer;import java.sql.Connection;import java.sql.SQLException;import java.util.Date;import java.util.List;/** * 用来定义规范针对于Customer表的常用操作 */public interface CustomerDAO &#123;    /**     * 将cust对象添加到数据库中     * @param conn     * @param cust     */    void insert(Connection conn, Customer cust) throws SQLException;    /**     * 针对指定的id，删除表中的一条记录     * @param conn     * @param id     */    void deleteById(Connection conn, int id) throws SQLException;    /**     * 针对内存中的cust对象，去修改数据表中指定的记录     * @param conn     * @param cust     */    void update(Connection conn,Customer cust) throws SQLException;    /**     * 针对指定的id查询得到对应的Customer对象     * @param conn     * @param id     */    Customer getCustomerById(Connection conn, int id) throws SQLException;    /**     * 查询表中的所有记录构成的集合     * @param conn     * @return     */    List&lt;Customer&gt; getAll(Connection conn) throws SQLException;    /**     * 返回数据表中的数据的条目数     * @param conn     * @return     */    Long getCount(Connection conn);    /**     * 返回数据表中最大的生日     * @param conn     * @return     */    Date getMaxBirth(Connection conn);&#125;</code></pre><h2 id="3-实现类"><a href="#3-实现类" class="headerlink" title="3.实现类"></a>3.实现类</h2><pre><code class="java">package com.DAO;import com.bean.Customer;import java.sql.Connection;import java.sql.SQLException;import java.util.Collections;import java.util.Date;import java.util.List;public class CustomerDAOImpl extends BaseDAO implements CustomerDAO&#123;    @Override    public void insert(Connection conn, Customer cust) throws SQLException &#123;    String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;    UpDate(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth());    &#125;    @Override    public void deleteById(Connection conn, int id) throws SQLException &#123;        String sql = &quot;delete from customers where id = ?&quot;;        UpDate(conn,&quot;delete from customers where id = ?&quot;,id);    &#125;    @Override    public void update(Connection conn, Customer cust) throws SQLException &#123;        String sql = &quot;update customers set name = ?,email = ?,birth = ? where id = ?&quot;;        UpDate(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getId());    &#125;    @Override    public Customer getCustomerById(Connection conn, int id) throws SQLException &#123;        String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;        Customer customer = getInstance(conn, Customer.class, sql, id);        return customer;    &#125;    @Override    public List&lt;Customer&gt; getAll(Connection conn) throws SQLException &#123;        String sql = &quot;select id,name,email,birth from customers&quot;;        List&lt;Customer&gt; list = Collections.singletonList(getForList(conn, Customer.class, sql));        return list;    &#125;    @Override    public Long getCount(Connection conn) &#123;        String sql = &quot;select count(*) from customers&quot;;        Long count = getValue(conn, sql);        return count;    &#125;    @Override    public Date getMaxBirth(Connection conn) &#123;        String sql = &quot;select max(birth) from customers&quot;;        Date maxBirth = getValue(conn, sql);        return maxBirth;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx快速入门</title>
      <link href="/2022/10/25/nginx%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2022/10/25/nginx%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一-初识nginx"><a href="#一-初识nginx" class="headerlink" title="一 .初识nginx"></a>一 .初识nginx</h2><h3 id="1-1-nginx特性及其优点"><a href="#1-1-nginx特性及其优点" class="headerlink" title="1.1 nginx特性及其优点"></a>1.1 nginx特性及其优点</h3><ul><li><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。</p></li><li><p>其特点是<strong>占有内存少，并发能力强</strong>，事实上nginx的<a href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91&spm=1001.2101.3001.7020">并发</a>能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p></li><li><p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。<strong>Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动</strong>。你还能够不间断服务的情况下进行软件版本的升级。</p></li><li><p>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。</p></li></ul><h3 id="1-2-nginx产生的原因"><a href="#1-2-nginx产生的原因" class="headerlink" title="1.2 nginx产生的原因"></a>1.2 nginx产生的原因</h3><ul><li><p>一个项目在初步开发的时候，并发量比较少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户。</p><p><img src="/../image/ecs/nginx1.png"></p></li></ul><ul><li><p>随着项目的使用和开展，使用平台的用户越来越多了，并发量慢慢增大了，这时候一台服务器满足不了我们的需求了</p><p><img src="/../image/ecs/nginx2.png"></p></li><li><p>于是我们横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。</p><p><img src="/../image/ecs/nginx3.png"></p></li></ul><pre><code>我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了Nginx。</code></pre><h2 id="二-nginx的代理"><a href="#二-nginx的代理" class="headerlink" title="二.nginx的代理"></a>二.nginx的代理</h2><h3 id="2-1-nginx-的正向代理"><a href="#2-1-nginx-的正向代理" class="headerlink" title="2.1 nginx 的正向代理"></a>2.1 nginx 的正向代理</h3><ul><li><p>正向代理：代理是代理客户端的<br><img src="/../image/ecs/zhengxiangdaili.png"></p></li><li><p>反向代理 ：代理是代理服务器的，所以用户是无感知的，比如，百度的服务器是在不同的服务器上，比如北京上海深圳都有百度的服务器，但是我们只需要搜索baidu.com就可以。</p><p><img src="/../image/ecs/fanxiangdaili.png"></p></li></ul><h3 id="2-2-nginx-的负载策略"><a href="#2-2-nginx-的负载策略" class="headerlink" title="2.2 nginx 的负载策略"></a>2.2 nginx 的负载策略</h3><p><strong>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。</strong></p><ul><li><p>轮询</p><p><img src="/../image/ecs/lunxun.png"></p></li><li><p>加权轮询，因为可能不同服务器性能不一样，能接收的请求数量不同</p><p><img src="/../image/ecs/jiaquanlunxun.png"></p></li><li><p>iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</p><p><img src="/../image/ecs/iph.png"></p></li><li><p>动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p></li></ul><p>​       <img src="/../image/ecs/dongjingfenli.png"></p><h2 id="三-nginx的安装和使用"><a href="#三-nginx的安装和使用" class="headerlink" title="三 . nginx的安装和使用"></a>三 . nginx的安装和使用</h2><ul><li><p>去官网进行下载</p><pre><code>http://nginx.org/en/download.html</code></pre><p>选择正确的版本，我这里下载的是linux版本</p><p><img src="/../image/ecs/nginxweb.png"></p></li><li><p>把下载好的压缩包通过命令或者SFTP传到服务器上，cd到传输的目录下，进行解压安装</p></li></ul><pre><code class="bash">tar -zxvf nginx-1.22.1.tar.gz # 解压安装包</code></pre><ul><li>执行.&#x2F;configure自动配置</li></ul><pre><code class="bash">./configure #自动配置</code></pre><ul><li>执行安装命令</li></ul><pre><code class="bash">make install #安装</code></pre><p><img src="/../image/ecs/nginxinstall.png"></p><ul><li><p>到安装目录下的objs进行启动nginx</p><p><img src="/../image/ecs/nginxmulu.png"></p></li><li><p>输入启动命令，没有报错就是启动成功</p><p><img src="/../image/ecs/nginxstart.png"></p><p>去浏览器检查默认的80端口，出现下面这个就是启动成功啦！云安全组也要放行80端口</p><p><img src="/../image/ecs/welcomenginx.png"></p><p>如何连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放80端口:</p><p><img src="/../image/ecs/duankou80.png"></p></li></ul><ul><li><p><strong>配置监听</strong></p><pre><code>nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。</code></pre><p><img src="/../image/ecs/peizhi.png"></p><pre><code>当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 nginx -s reload 即可让改动生效</code></pre></li><li><p><strong>关闭Nginx</strong></p><p>如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx</p><p>(1)输入nginx命令 nginx -s stop(快速停止nginx) 或 nginx -s quit(完整有序的停止nginx)</p><p>(2)使用taskkill taskkill &#x2F;f &#x2F;t &#x2F;im nginx.exe</p><pre><code class="bash">taskkill是用来终止进程的，/f是强制终止 ./t终止指定的进程和任何由此启动的子进程。/im示指定的进程名称 .</code></pre></li></ul><h2 id="四-nginx命令"><a href="#四-nginx命令" class="headerlink" title="四. nginx命令"></a>四. nginx命令</h2><pre><code class="bash">cd /usr/local/nginx/sbin/./nginx  启动./nginx -s stop  停止./nginx -s quit  安全退出./nginx -s reload  重新加载配置文件ps aux|grep nginx  查看nginx进程</code></pre><p>防火墙的相关命令:</p><pre><code class="bash"># 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all# 查询端口是否开放firewall-cmd --query-port=8080/tcp# 开放80端口firewall-cmd --permanent --add-port=80/tcp# 移除端口firewall-cmd --permanent --remove-port=8080/tcp#重启防火墙(修改配置后要重启防火墙)firewall-cmd --reload# 参数解释1、firwall-cmd：是Linux提供的操作firewall的一个工具；2、--permanent：表示设置为持久；3、--add-port：标识添加的端口；</code></pre><h2 id="五-尝试使用nginx"><a href="#五-尝试使用nginx" class="headerlink" title="五. 尝试使用nginx"></a>五. 尝试使用nginx</h2><ul><li>先进行配置文件的修改</li></ul><pre><code class="bash">http &#123;    ...    upstream cvzhanshi&#123;        server 127.0.0.1:8082/ weight=1;        server 127.0.0.1:8081/ weight=1;    &#125;    server &#123;        listen       80;        server_name  localhost;        location / &#123;            root   html;            index  index.html index.htm;            proxy_pass http://cvzhanshi;        &#125;        ...&#125;</code></pre><ul><li><p>启动两个端口的项目</p><p><img src="/../image/ecs/qiyongshuangduankou.png"></p></li><li><p>启动nginx</p></li><li><p>进行测试</p><p><img src="/../image/ecs/testnginx.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> 服务器代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云之初体验</title>
      <link href="/2022/10/23/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2022/10/23/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="1-首次接触服务器"><a href="#1-首次接触服务器" class="headerlink" title="1.首次接触服务器"></a>1.首次接触服务器</h3><p>​本人是一名有幸刚考到电子信息专业的一名研一的学生。由于自己导师的需求，自己最近须要了解并学习web开发相关的知识，当然把web部署到服务器也是很重要的技能。于是通过了解和同学的推荐，他们告诉我阿里云的ECS服务器是最好用的，对小白也都非常友好，于是我抱着试试看的心态就去阿里云官网看了一下，于是就发现了，“飞天加速计划·高校学生在家实践”活动，这个活动对高校的学生非常优惠，于是我通过第一阶段的学习成功拿到了14天ECS的免费试用！</p><h3 id="2-我的阿里云使用体验"><a href="#2-我的阿里云使用体验" class="headerlink" title="2.我的阿里云使用体验"></a>2.我的阿里云使用体验</h3><p>​  通过在阿里云的第一阶段的训练，我已经可以去创建并操作一个我的实例了。<img src="/../image/ecs/p1.png"></p><p>​  创建好了第一个实例以后，我使用Terimius1工具连接到了ECS，连接过程也是非常快:</p><p><img src="/../image/ecs/p2.png"></p><p>​之前说过我组租服务器，是为了web开发的学习，所以我在我的服务器通过yum安装了jdk1.8的和mysql8的开发环境，通过yum安装jdk1.8的过程还是十分的顺利，只需要一行命令即可，可以说比windows安装还要方便。</p><p>​在centos7.9上安装jdk1.8只用了以下两个命令：</p><pre><code class="shell">yum list java-1.8*                   //在yum中查找可以安装的jdk版本 yum install java-1.8.0-openjdk* -y   //开始安装</code></pre><p>​紧接着，我写了一个java文件来测试我的java环境是否配置好了。一次测试成功！</p><p><img src="/../image/ecs/p3.png"></p><p>然后我就在服务器开始安装我的mysql8。</p><p>因为之前安装jdk1.8的时候已经启用了yum的存储库，所以在这直接用yum进行安装。</p><pre><code class="shell">yum --enablerepo=mysql80-community install mysql-community-server   //执行这个命令进行安装</code></pre><p>​</p><aside>💡 如果安装提示 **The GPG keys listed for the “MySQL 8.0 Community Server“ repository are already installed but……**</aside><p>请执行以下命令后，重新进行安装：</p><pre><code class="shell">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</code></pre><p>安装好之后就可以启动我的mysql8的数据库，再通过阿里云服务器开发3306端口，在通过Navicat15的连接，很快就连接到了我的ECS上的mysql8。</p><p><img src="/../image/ecs/p5.png"></p><p><img src="/../image/ecs/p4.png"></p><p>现在环境就基本配置好了，下一步准备学习把网站部署到服务器上。</p><h3 id="3-总结展望"><a href="#3-总结展望" class="headerlink" title="3.总结展望"></a>3.总结展望</h3><p>​总的来说，阿里云的ECS给我的印象还是十分好的，操作简单，自由度很高非常容易上手，也感谢阿里云给我的这次体验机会，我也希望能继续续领阿里的ECS服务器进行更多的操作和学习。感谢阿里云给我们这么好的平台！</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> aliyun </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发的环境部署</title>
      <link href="/2022/10/23/Web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/10/23/Web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一-开发环境搭建"><a href="#一-开发环境搭建" class="headerlink" title="一.开发环境搭建"></a>一.开发环境搭建</h2><h3 id="1-JDK安装"><a href="#1-JDK安装" class="headerlink" title="1.JDK安装"></a>1.JDK安装</h3><ul><li>去Oracle的官网，找到JDK8的Windows安装包，并下载</li></ul><p><img src="/../image/web1/Oracle.png"></p><ul><li>双击exe文件进行安装</li></ul><p>选择好安装的目录，一直点击下一步就可以安装成功</p><p><img src="/../image/web1/jdkinstall.png"></p><ul><li>配置计算机的环境变量</li></ul><p>在Windows搜索框搜索高级系统设置，点击查看高级系统设置</p><p><img src="/../image/web1/xitongshezhi.png"></p><p>点击高级选项卡中的系统变量</p><p><img src="/../image/web1/xuanxiangka.png"></p><p>在下方的系统变量中，新建一个JAVA_HOME的系统变量,路径写刚才JDK安装的路径</p><p><img src="/../image/web1/JAVA_HOME.png"></p><p>在path中添加JAVA_HOME</p><p><img src="/../image/web1/path1.png"></p><p><img src="/../image/web1/path2.png"></p><ul><li>JDk安装完成</li></ul><h3 id="2-IDEA安装"><a href="#2-IDEA安装" class="headerlink" title="2. IDEA安装"></a>2. IDEA安装</h3><ul><li>去<strong>JetBrains</strong>的官网下载idea的安装包</li></ul><pre><code>IDEA下载地址：https://www.jetbrains.com/idea/download/#section=windows  </code></pre><p><img src="/../image/web1/ideadownload.png"></p><ul><li>双击exe打开安装程序，点击下一步</li></ul><p><img src="/../image/web1/jb.png"></p><ul><li>选择好自己的文件目录，不建议放在C盘，会消耗较多的硬盘空间。</li></ul><p><img src="/../image/web1/idea1.png"></p><ul><li>红色箭头这里是电脑的位数</li><li>绿色箭头这里是关联相对应的文件，当双击该格式文件的时候，会自动的使用idea打开，不推荐勾选</li><li>蓝色箭头是建议在安装JetBrain时选择自动安装一个jre，这里不会与原来jre冲突推荐安装</li></ul><p><img src="/../image/web1/idea2.png"></p><ul><li>点击install，即可安装成功</li></ul><p><img src="/../image/web1/idea3.png"></p><h3 id="3-MySQL-amp-Navicat"><a href="#3-MySQL-amp-Navicat" class="headerlink" title="3. MySQL&amp;Navicat"></a>3. MySQL&amp;Navicat</h3><ul><li>去MySQL下载安装包,下载下面这个431M的</li></ul><pre><code class="http">https://dev.mysql.com/downloads/installer/</code></pre><p><img src="/../image/web1/mysqld.png"></p><ul><li><p>下载完成后双击打开开始安装,选择最后一个自定义安装，点击back，在选择第一个，点击back，在点击自定义安装</p><p><img src="/../image/web1/bug.png"></p></li><li><p>可以自定义一下每个套件的安装路径，自定义完之后，点击next</p><p><img src="/../image/web1/lujing.png"></p></li><li><p>点击Excute,检查没有错误在点击next</p><p><img src="/../image/web1/excuat1.png"></p></li><li><p>在此点击Excute</p><p><img src="/../image/web1/excute2.png"></p></li><li><p>检查须要一点时间，完毕之后点击next</p><p><img src="/../image/web1/next.png"></p></li><li><p>因为我们要连接Navicat所以选择旧式密码</p></li></ul><p><img src="/../image/web1/oldpass.png"></p><ul><li><p>输入两次你的数据库root密码，点击next</p><p><img src="/../image/web1/doupass.png"></p></li><li><p>点击Next</p><p><img src="/../image/web1/next2.png"></p></li><li><p>点击Excute</p><p><img src="/../image/web1/excute3.png"></p></li><li><p>配置MySQL的环境变量，在path中加入刚才安装mysql的server的bin目录下的路径</p><p><img src="/../image/web1/xauat.png"></p><p><img src="/../image/web1/path4.png"></p></li><li><p>测试MySQL是否安装成功，输入mysql -u root -p登录</p><p><img src="/../image/web1/loginmysql.png"></p><ul><li>登录测试成功</li></ul></li><li><p>下面进行Navicat的安装，自己找一下破解版的安装包，解压后，在目录下找打navicat.exe双击运行即可</p><p><img src="/../image/web1/navicatexe.png"></p></li><li><p>进入软件点击连接，点击MySQL</p><p><img src="/../image/web1/mysql1.png"></p></li><li><p>主机名可以自定义填写，密码填写当时创建MySQL的密码</p></li></ul><p><img src="/../image/web1/mysql5.png"></p><ul><li><p>点击确定或者测试连接，就可以看到连接成功了！</p><p><img src="/../image/web1/mysql6.png"></p></li></ul><h3 id="4-Tomcat安装"><a href="#4-Tomcat安装" class="headerlink" title="4.Tomcat安装"></a>4.Tomcat安装</h3><ul><li>进如Tomcat的官网，选择要下载的版本</li></ul><p><img src="/../image/web1/tomcatweb.png"></p><ul><li><p>建议下载Tomcat8的压缩包，Tomcat8和jdk8是对应兼容的</p><p><img src="/../image/web1/tomcat1.png"></p></li><li><p>下载完解压到自己想安装的目录即可，打开解压后的目录文件，找到bin目录下</p><p><img src="/../image/web1/tomcat2.png"></p></li><li><p>双击bin目录下的startup.bat启动Tomcat服务</p><p><img src="/../image/web1/tomcat3.png"></p></li><li><p>启动后，在浏览器的地址栏输入localhost:8080 ,如果跳出以下界面就表示安装成功<br> <img src="/../image/web1/tomcat4.png"></p></li><li><p>Tomcat的环境变量配置，和之前JDk，MySQL配置环境变量类似,先新建系统变量，在配置path<br> <img src="/../image/web1/tomcat5.png"></p></li></ul><p><img src="/../image/web1/tomcat6.png"></p><pre><code class="bash">%CATALINA_HOME%\lib;%CATALINA_HOME%\lib\servlet-api.jar;%CATALINA_HOME%\lib\jsp-api.jar;</code></pre><h3 id="5-redis安装"><a href="#5-redis安装" class="headerlink" title="5. redis安装"></a>5. redis安装</h3><p>项目用到了redis，不安装的话后端会启动失败</p><p>首先打开redis 的官网</p><pre><code class="http">https://redis.io/download/#redis-downloads</code></pre><p><img src="/../image/web1/redis.png"></p><p>下载，解压到想安装的目录，先点击redis-server.exe，启动redis服务</p><p><img src="/../image/web1/redis2.png"></p><p>然后双击redis-cli.exe，输入ping，如果显示PONG就是启动成功</p><p><img src="/../image/web1/redis3.png"></p><h3 id="6-VsCode"><a href="#6-VsCode" class="headerlink" title="6. VsCode"></a>6. VsCode</h3><p>VsCode一款非常好用的免费编码工具，去官网就可以下载安装，非常简单，不过多赘述</p><pre><code class="http">https://code.visualstudio.com/download</code></pre><p>  <img src="/../image/web1/vs1.png"></p><h3 id="7-nodejs安装"><a href="#7-nodejs安装" class="headerlink" title="7. nodejs安装"></a>7. nodejs安装</h3><p>想启动Vue项目须要下载安装nodejs，在官网下载，解压到想安装的目录就可以</p><pre><code class="http">https://nodejs.org/zh-cn/download/</code></pre><p><img src="/../image/web1/nodejs1.png"></p><p>​npm会和nodejs一起安装好，可以在命令行检查是否安装好了npm和nodejs,查看安装的版本</p><p><img src="/../image/web1/npm1.png"></p><h3 id="8-Termius安装（可以不装）"><a href="#8-Termius安装（可以不装）" class="headerlink" title="8. Termius安装（可以不装）"></a>8. Termius安装（可以不装）</h3><ul><li><p>可以下载一个远程连接服务器工具，我觉得比较好用Termius，也可以用宝塔的终端</p><p>下载地址</p><pre><code class="http">https://termius.com/windows</code></pre><p><img src="/../image/web1/termius.png"></p><p>添加host</p><p><img src="/../image/web1/termius2.png"></p></li></ul><h2 id="二-服务器环境搭建"><a href="#二-服务器环境搭建" class="headerlink" title="二. 服务器环境搭建"></a>二. 服务器环境搭建</h2><h3 id="1-先到阿里云学生的活动页面登录领取14天"><a href="#1-先到阿里云学生的活动页面登录领取14天" class="headerlink" title="1. 先到阿里云学生的活动页面登录领取14天"></a>1. 先到阿里云学生的活动页面登录领取14天</h3><pre><code class="http">https://developer.aliyun.com/plan/student#J_5144437010</code></pre><p><img src="/../image/ecs/p6.png"></p><ul><li>点击这里进行领取，如果没有进行学生认证的话，先在支付宝进行学生的认证。认证之后，跳转到到完成新手营界面，进行服务器的新手训练，按照提示操作即可，还有一个十道题的小测验，答案我放在下方的链接,如果没有可以自行百度：</li></ul><pre><code class="http">https://blog.csdn.net/qq_35834501/article/details/106539233</code></pre><pre><code class="http">https://blog.csdn.net/qq_45037404/article/details/104552886</code></pre><pre><code class="http">https://blog.csdn.net/Miracle_ps/article/details/104555821</code></pre><ul><li>完成上述的任务就可以领取14天的ECS服务器啦！</li></ul><p>领取服务器的时候选择<strong>Centos系统</strong>就可以，如果选错了不要紧，后面更换很简单。</p><h3 id="2-投稿并续领两个月的ECS"><a href="#2-投稿并续领两个月的ECS" class="headerlink" title="2. 投稿并续领两个月的ECS"></a>2. 投稿并续领两个月的ECS</h3><ul><li>点击免费续领：</li></ul><p><img src="/../image/ecs/p7.png"></p><ul><li>跳转到以下页面：</li></ul><p><img src="/../image/ecs/p8.png"></p><ul><li>按照要求水一篇赞美阿里云的小文章，<strong>markdown</strong>格式，在社区发布，发布后把链接给管理员审核通过即可续费两个月！</li></ul><p>如果不知道写的格式，可以参考我的上一篇文章，<strong>阿里云之初体验</strong>。审核须要一定时间不要着急。</p><h3 id="3-通过命令安装宝塔面板"><a href="#3-通过命令安装宝塔面板" class="headerlink" title="3. 通过命令安装宝塔面板"></a>3. 通过命令安装宝塔面板</h3><ul><li>首先获取该实例的密码，如果不记得可以去下面网页一键重置</li></ul><p><img src="/../image/ecs/repass.png"></p><ul><li>通过<strong>SSH</strong>进行远程登录ECS，可以用阿里云控制台远程登录</li></ul><p><img src="/../image/ecs/workbench.png"></p><p><img src="/../image/ecs/loginssh.png"></p><ul><li><p>访问失败的去安全组看下22端口是否开放。</p></li><li><p>也可以安装远程连接软件，软件用起来会比阿里网页这个流畅一些，在这里我用的是Terimius工具，须要输入服务器ip地址，ssh的连接的用户名和密码，就是重置实例的用户名和密码。</p></li></ul><p><img src="/../image/ecs/termiuslogin.png"></p><ul><li>接下来我们去官网找到宝塔面板相应系统的下载命令复制后直接在命令行输入</li></ul><p><img src="/../image/ecs/baotaweb.png"></p><ul><li>输入该命令行后，服务器开始安装宝塔面板，耐心等待一会这里会有两次询问，输入y和yes就可以完成下载，出现以下的图片就说明宝塔面板安装成功！记得把红框内的内外网地址和用户名密码保存起来，可以放在记事本中，用到了就去看一下。</li></ul><p><img src="/../image/ecs/installbaota.png"></p><p><img src="/../image/ecs/baotainstall.png"></p><ul><li>接下来我们把上图出现的外网地址复制到浏览器，并输入上面写的用户名和密码</li></ul><p><img src="/../image/ecs/baotalogin.png"></p><ul><li>如果登录不上，去检查一下控制台安全组有没有<strong>放行宝塔的端口号</strong>。</li></ul><p>登录进去以后，要绑定你的宝塔账号，如果没有先注册一个</p><p><img src="/../image/ecs/baotauser.png"></p><h3 id="4-通过宝塔面板和命令安装应用"><a href="#4-通过宝塔面板和命令安装应用" class="headerlink" title="4.通过宝塔面板和命令安装应用"></a>4.通过宝塔面板和命令安装应用</h3><ul><li>注册完毕后，会弹出弹窗，在这里你可以勾选自己须要的应用以及版本进行快速安装,也可以一会去左侧导航栏里面的软件商店搜索安装，点击极速安装就可以。</li></ul><p><img src="/../image/ecs/baotainstallapp.png"></p><ul><li>下面是本次web开发所可能需要的端口，请在阿里云的安全组进行开发下列端口</li></ul><p><img src="/../image/ecs/duankouhao.png"></p><ul><li>本次还用到了Tomcat,Redis,Nginx,均可以在宝塔面板的软件商店进行一键安装。</li></ul><p><img src="/../image/ecs/anzhuang.png"></p><ul><li><p>其中Nginx需要在宝塔改一下配置文件，如果不了解Nginx可以看下本站的上上篇文章<strong>Nginx快速入门</strong></p><p><img src="/../image/ecs/nginxconfig.png"></p></li><li><p>通过yum安装JDK   [在远程连接的命令行输入]</p><pre><code class="bash">yum list java-1.8*                   //在yum中查找可以安装的jdk版本 yum install java-1.8.0-openjdk* -y   //开始安装</code></pre><p>紧接着，我写了一个java文件来测试我的java环境是否配置好了。一次测试成功！</p><p><img src="/../image/ecs/p3.png"></p></li></ul><h3 id="3-配置并用Navicat连接ECS的mysql"><a href="#3-配置并用Navicat连接ECS的mysql" class="headerlink" title="3.配置并用Navicat连接ECS的mysql"></a>3.配置并用Navicat连接ECS的mysql</h3><ul><li>在宝塔面板下载好mysql之后，点击左侧导航栏数据库，获取到root密码后，在命令行输入mysql -u root -p和密码登录到mysql中</li></ul><p><img src="/../image/ecs/getpassword.png"></p><p><img src="/../image/ecs/mysqllogin.png"></p><ul><li>因为mysql现有的用户都是localhost的，所以须要创建一个可以远程访问的mysql用户，或者给root用户增加权限。</li></ul><pre><code class="shell">create user &#39;用户名&#39;@&#39;允许那个主机链接&#39; identified by &#39;密码&#39;;           // 创建新用户 %  主机名为所有主机可以连接grant all privileges on *.* to &#39;用户名&#39;@&#39;主机名&#39; with grant option;   //授予该用户若有权限flush privileges;                                                   //刷新权限quit                   //退出mysqlservice mysqld restart //重启mysql</code></pre><p><img src="/../image/ecs/mysqlcreatuser.png"></p><ul><li>因为centos自带防火墙，所以还要在centos中放行tcp3306端口</li></ul><pre><code class="shell">firewall-cmd --list-all   // 查看开放的端口号firewall-cmd --zone=public --add-port=3306/tcp --permanent   // 开放3306端口firewall-cmd --reload// 重启防火墙firewall-cmd --list-all     //查看是否生效</code></pre><p><img src="/../image/ecs/centosfrrewall.png"></p><ul><li>接下来就用创建好的用户名和密码通过Navicat进行连接mysql,连接名可以任意</li></ul><p><img src="/../image/ecs/navicat15connect.png"></p><ul><li>连接成功！</li></ul><p><img src="/../image/ecs/navicatconnectend.png"></p><h3 id="4-通过Navicat-导入数据库文件"><a href="#4-通过Navicat-导入数据库文件" class="headerlink" title="4. 通过Navicat 导入数据库文件"></a>4. 通过Navicat 导入数据库文件</h3><ul><li>先创建好对应的数据库，字符集是utf8mb64,排序规则可以不用写</li></ul><p><img src="/../image/ecs/createdatabase.png"></p><ul><li>点击数据库进行右键，点击执行sql文件，把须要导入的sql文件导入</li></ul><p><img src="/../image/ecs/zhixingsql.png"></p><p><img src="/../image/ecs/yunxingsql.png"></p><ul><li>完事点击关闭就可以了，点击数据库右键刷新，就可以看到表格和数据都已经导入进去了。</li></ul><p><img src="/../image/ecs/daoruchenggong.png"></p><ul><li>至此，web在ECS须要的软件环境准备好了。</li></ul><h2 id="三-部署系统"><a href="#三-部署系统" class="headerlink" title="三.部署系统"></a>三.部署系统</h2><h3 id="1-Web项目在本地运行"><a href="#1-Web项目在本地运行" class="headerlink" title="1. Web项目在本地运行"></a>1. Web项目在本地运行</h3><h4 id="1-1-本地后端运行"><a href="#1-1-本地后端运行" class="headerlink" title="1.1 本地后端运行"></a>1.1 本地后端运行</h4><ul><li>以<strong>管理员</strong>身份打开idea，打开项目的源码，点击上方工具栏的<strong>Build→Rebuild</strong>重新构建一下项目。</li></ul><p>​   <img src="/../image/web1/web1.png"></p><ul><li><p>点击上方的绿色箭头就可以启动项目</p><p><img src="/../image/web1/web2.png"></p></li><li><p>若启动成功，则会有以下显示</p><p><img src="/../image/web1/webb.png"></p></li><li><p>如果启动不成功，在RuoYi-Vue-master\ruoyi-admin\src\main\resources\application-druid.yml里查看mysql用户名密码是否正确</p><p>检查redis是否成功启动，</p><p>根据报错日志来调试</p></li></ul><h4 id="1-2-本地前端运行"><a href="#1-2-本地前端运行" class="headerlink" title="1.2 本地前端运行"></a>1.2 本地前端运行</h4><ul><li><p>先用VsCode打开项目源码ruoyi-ui，打开Vscode的新建终端</p></li><li><p>npm install</p><p>1、进入项目路径(磁盘: cd文件夹目录）</p><p>2、执行命令：npm install</p><p><img src="/../image/web1/npm2.png"></p></li><li><p>本地启动项目 npm run dev</p><p><img src="/../image/web1/npm3.png"></p></li><li><p>去localhost查看启动效果</p><p><img src="/../image/web1/npm4.png"></p></li></ul><h3 id="2-Web项目在ECS的部署"><a href="#2-Web项目在ECS的部署" class="headerlink" title="2. Web项目在ECS的部署"></a>2. Web项目在ECS的部署</h3><h4 id="2-1后端部署"><a href="#2-1后端部署" class="headerlink" title="2.1后端部署"></a>2.1后端部署</h4><ul><li>通过idea的Maven工具给源码打jar包</li></ul><p>首先要以<strong>管理员</strong>身份打开idea，打开项目的源码，点击上方工具栏的<strong>Build→Rebuild</strong>重新构建一下项目。然后按照下面图片的方法进行打包</p><p><img src="/../image/web1/maven.png"></p><ul><li>打完的包在这个目录下就可以看到</li></ul><p><img src="/../image/web1/jar.png"></p><ul><li>把打好的jar包上传到服务器</li></ul><p>可以用宝塔的文件传输或者是Termius的SFTP功能来把jar包传出到服务器</p><p><img src="/../image/web1/termiuspush.png"></p><ul><li>宝塔面板的文件传输功能也可把文件上传</li></ul><p><img src="/../image/web1/btpush.png"></p><ul><li><p>接下来在传输文件的目录下使用命令行把后端运行起来</p><pre><code class="bash">nohup java -jar 你的jar包名称.jar&gt; springboot.log 2&gt;&amp;1 &amp; #后台运行jar包的命令</code></pre><p><img src="/../image/web1/qidong.png"></p></li><li><p>启动后去看一下刚才文件夹生成的log日志，稍等一会（大约20秒），会把日志生成好，看到红框的内容就是启动成功了，如果没有启动成功的话，大概率是数据库和端口的问题。</p><p><img src="/../image/web1/log.png"></p></li></ul><h4 id="2-2前端部署"><a href="#2-2前端部署" class="headerlink" title="2.2前端部署"></a>2.2前端部署</h4><ul><li><p>和上面后端传输jar包的方式相同，通过Termius的SFTP或者是宝塔的文件传输，把前端的压缩包传输到服务器</p><p><img src="/../image/web1/pushzip.png"></p></li><li><p>把压缩包进行解压</p></li></ul><pre><code class="bash">unzip zipped_file.zip  #解压命令</code></pre><p>解压完毕后，该文件夹下面会出现一个解压后的文件</p><p><img src="/../image/web1/jieyawancheng.png"></p><p>点开解压文件找到文件dist的路径，把该路径配置到Nginx的配置文件中，Nginx会自动启动前端的服务</p><p><img src="/../image/web1/dist.png"></p><p><img src="/../image/web1/nginxpeizhi.png"></p><p><img src="/../image/web1/nginxshezhi.png"></p><ul><li><p>至此，web项目在服务器前后端部署好了，在浏览器输入你的ip地址，就可以正常访问系统了！</p><p><img src="/../image/web1/end.png"></p></li></ul><h2 id="四-模拟数据发送"><a href="#四-模拟数据发送" class="headerlink" title="四. 模拟数据发送"></a>四. 模拟数据发送</h2><h3 id="1-UDP通信"><a href="#1-UDP通信" class="headerlink" title="1. UDP通信"></a>1. UDP通信</h3><h4 id="1-1-UDP简介"><a href="#1-1-UDP简介" class="headerlink" title="1.1 UDP简介"></a>1.1 UDP简介</h4><pre><code>UDP（UserDatagramProtocol）是一个简单的面向消息的传输层协议，尽管UDP提供标头和有效负载的完整性验证（通过校验和），但它不保证向上层协议提供消息传递，并且UDP层在发送后不会保留UDP 消息的状态。因此，UDP有时被称为不可靠的数据报协议。如果需要传输可靠性，则必须在用户应用程序中实现。</code></pre><ul><li><p>UDP是基于IP的简单协议，不可靠的协议。</p></li><li><p>UDP的优点：简单，轻量化。</p></li><li><p>UDP的缺点：没有流控制，没有应答确认机制，不能解决丢包、重发、错序问题。</p></li></ul><h4 id="1-2-DatagramSocket-类"><a href="#1-2-DatagramSocket-类" class="headerlink" title="1.2 DatagramSocket 类"></a>1.2 DatagramSocket 类</h4><pre><code>DatagramSocket 类用于表示发送和接收数据报包的套接字。数据报包套接字是包投递服务的发送或接收点。每个在数据报包套接字上发送或接收的包都是单独编址和路由的。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</code></pre><ul><li>构造方法</li></ul><p>（1）DatagramSocket()<br>绑定到本地地址和一个随机的端口号</p><p>（2）DatagramSocket(int port)<br>绑定本地地址和一个特定的端口号</p><p>（3）DatagramSocket(int port, InetAddress iad)<br>绑定到特定的端口号及指定地址</p><p>（4）DatagramSocket(SocketAddress sad)<br>绑定指定地址和随机端口号</p><ul><li>基本方法</li></ul><p>（1）close()<br>关闭套接字</p><p>（2）recevie(DatagramPacket dp)<br>接受数据报</p><p>（3）send(DatagramPacket dp)<br>发送数据报</p><h4 id="1-3-DatagramPacket-类"><a href="#1-3-DatagramPacket-类" class="headerlink" title="1.3 DatagramPacket 类"></a>1.3 DatagramPacket 类</h4><pre><code>java.net 包中的 DatagramPacket 类用来表示数据报包，数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</code></pre><ul><li>接受类型</li></ul><p>（1）DatagramPacket(byte[] buf, int length)<br>用来接受长度为length的buf数据(即数据存于字节数组buf中)</p><ul><li>发送类型</li></ul><p>（1）DatagramPacket(byte[] buf, int length, InetAddress address, int port)<br>将length长的buf数据发送到指定的地址的端口号处</p><p>（2）DatagramPacket(byte[] buf, int length, SocketAddress address)<br>将length长的buf数据发送到指定的套接字地址处</p><h3 id="2-发送程序"><a href="#2-发送程序" class="headerlink" title="2. 发送程序"></a>2. 发送程序</h3><ul><li><p>定义服务器的地址、端口号</p><pre><code class="java">InetAddress address = InetAddress.getByName(&quot;121.5.149.32&quot;);int port = 1902;</code></pre></li><li><p>创建一个DatagramSocket对象，端口号可以默认</p><pre><code class="java">DatagramSocket socket = new DatagramSocket();</code></pre></li><li><p>定义时间的格式</p><pre><code class="java">SimpleDateFormat format=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</code></pre></li><li><p>创建一个定时任务，用于向项目定时发数据,在task的run方法中去写我们的定时任务</p><pre><code class="java">TimerTask task = new TimerTask();public void run() &#123;&#125;Timer timer = new Timer();timer.schedule(task, 0, 1000*60*5); // 立即执行一次task，然后每隔2秒执行一次task</code></pre></li><li><p>以下是发送信息的主题主要用上面的Socket的对象，发送一个Packet类型的数据，Packet里面包含服务器地址，端口号和发送的数据</p><pre><code class="java"> int numArr[] = &#123;301,303,304&#125;;                String arr[]=new String[3];                arr[0]=&quot;01 38 46 32 37 32 37 29 46 2A 11 2B EE 29 EF 2B 14 EF&quot;;   //301设备数据发送(8路)                arr[1]=&quot;03 38 46 32 37 32 37 29 46 2A 11 2B EE 29 EF 2B 14 3A 0A 3A E3 48 50 48 4F 57 4A  39 CA 48 54 39 4F EF&quot;;//303设备数据发送(16路)                arr[2]=&quot;04 38 46 32 37 32 37 29 46 2A 11 2B EE 29 EF 2B 14 3A 0A 3A E3 48 50 48 4F 57 4A      39 CA 48 54 39 4F EF&quot;;//304设备数据发送(16路）                for (int i = 0; i &lt; arr.length; i++) &#123;                    String data = arr[i];                    byte bdata[]=hexStringToByteArray(data);                    DatagramPacket packet = new DatagramPacket(bdata,bdata.length, address, port);                    try &#123;                        socket.send(packet);                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(numArr[i]+&quot;通道发送成功&quot;+&quot;==&gt;发送时间：&quot;+format.format(new Date()));                &#125;</code></pre></li><li><p>发送程序的数据格式</p><pre><code>数据的内容主要格式如下：&quot;01 38 46 32 37 32 37 29 46 2A 11 2B EE 29 EF 2B 14 EF&quot;主体为16进制字节数组长度为18位(8路)或34位（16路）第一位代表了设备号（数据库根据设备号查询对应的项目，以及每一路通道代表的数据类型）。中间的第2位到弟17位，（或者第2位到第33位）这些数值每两位为一组，一组代表一个通道的数据。最后一位即第18位（34位），为数据结束标志位，规定为”EF”或”ef”。若不是这个则表明数据不正确。</code></pre></li><li><p>将字符串转换为字节数组的函数</p><pre><code class="java">   public static byte[] hexStringToByteArray(String hexString) &#123;        hexString = hexString.replaceAll(&quot; &quot;, &quot;&quot;);        int len = hexString.length();        byte[] bytes = new byte[len / 2];        for (int i = 0; i &lt; len; i += 2) &#123;            // 两位一组，表示一个字节,把这样表示的16进制字符串，还原成一个字节            bytes[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) &lt;&lt; 4) + Character                    .digit(hexString.charAt(i + 1), 16));        &#125;        return bytes;    &#125;</code></pre></li></ul><h3 id="3-运行程序"><a href="#3-运行程序" class="headerlink" title="3.运行程序"></a>3.运行程序</h3><ul><li>把写好的java文件<strong>去掉头文件包名</strong>之后通过文件传输到服务器的硬盘中,并且终端到该目录下</li></ul><pre><code class="bash">javac TimeSend.java  # 编译java文件生成可执行文件nohup java TimeSend &gt; test.log 2&gt;&amp;1 &amp;  #  后台运行java文件并产生日志ps -ef    # 查看进程kill 进程号    #杀掉进程</code></pre><ul><li>在该目录运行日志里查看运行是否成功</li></ul><p><img src="/../image/web1/fasong1.png"></p><ul><li><p>在web端的历史数据里查看是否有新生成的数据</p><p><img src="/../image/web1/fasong2.png"></p></li><li><p>数据模拟发送成功</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> aliyun </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
